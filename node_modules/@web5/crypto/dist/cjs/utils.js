"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomUuid = exports.randomBytes = exports.multibaseIdToKey = exports.isWebCryptoSupported = exports.keyToMultibaseId = exports.checkValidProperty = exports.checkRequiredProperty = void 0;
var crypto_1 = require("@noble/hashes/crypto");
var common_1 = require("@web5/common");
var utils_1 = require("@noble/hashes/utils");
/**
 * Checks whether the properties object provided contains the specified property.
 *
 * @param property Property key to check for.
 * @param properties Properties object to check within.
 * @returns void
 * @throws {SyntaxError} If the property is not a key in the properties object.
 */
function checkRequiredProperty(options) {
    if (!options || options.property === undefined || options.inObject === undefined) {
        throw new TypeError("One or more required parameters missing: 'property, properties'");
    }
    var property = options.property, inObject = options.inObject;
    if (!(property in inObject)) {
        throw new TypeError("Required parameter missing: '".concat(property, "'"));
    }
}
exports.checkRequiredProperty = checkRequiredProperty;
/**
 * Checks whether the property specified is a member of the list of valid properties.
 *
 * @param property Property key to check for.
 * @param allowedProperties Properties Array, Map, or Set to check within.
 * @returns void
 * @throws {SyntaxError} If the property is not a member of the allowedProperties Array, Map, or Set.
 */
function checkValidProperty(options) {
    if (!options || options.property === undefined || options.allowedProperties === undefined) {
        throw new TypeError("One or more required parameters missing: 'property, allowedProperties'");
    }
    var property = options.property, allowedProperties = options.allowedProperties;
    if ((Array.isArray(allowedProperties) && !allowedProperties.includes(property)) ||
        (allowedProperties instanceof Set && !allowedProperties.has(property)) ||
        (allowedProperties instanceof Map && !allowedProperties.has(property))) {
        var validProperties = Array.from((allowedProperties instanceof Map) ? allowedProperties.keys() : allowedProperties).join(', ');
        throw new TypeError("Out of range: '".concat(property, "'. Must be one of '").concat(validProperties, "'"));
    }
}
exports.checkValidProperty = checkValidProperty;
function keyToMultibaseId(options) {
    var key = options.key, multicodecCode = options.multicodecCode, multicodecName = options.multicodecName;
    var prefixedKey = common_1.Multicodec.addPrefix({ code: multicodecCode, data: key, name: multicodecName });
    var prefixedKeyB58 = common_1.Convert.uint8Array(prefixedKey).toBase58Btc();
    var multibaseKeyId = common_1.Convert.base58Btc(prefixedKeyB58).toMultibase();
    return multibaseKeyId;
}
exports.keyToMultibaseId = keyToMultibaseId;
/**
 * Checks if the Web Crypto API is supported in the current runtime environment.
 *
 * The function uses `globalThis` to provide a universal reference to the global
 * scope, regardless of the environment. `globalThis` is a standard feature introduced
 * in ECMAScript 2020 that is agnostic to the underlying JavaScript environment, making
 * the code portable across browser, Node.js, and Web Workers environments.
 *
 * In a web browser, `globalThis` is equivalent to the `window` object. In Node.js, it
 * is equivalent to the `global` object, and in Web Workers, it corresponds to `self`.
 *
 * This method checks for the `crypto` object and its `subtle` property on the global scope
 * to determine the availability of the Web Crypto API. If both are present, the API is
 * supported; otherwise, it is not.
 *
 * @returns A boolean indicating whether the Web Crypto API is supported in the current environment.
 *
 * Example usage:
 *
 * ```ts
 * if (isWebCryptoSupported()) {
 *   console.log('Crypto operations can be performed');
 * } else {
 *   console.log('Crypto operations are not supported in this environment');
 * }
 * ```
 */
function isWebCryptoSupported() {
    if (globalThis.crypto && globalThis.crypto.subtle) {
        return true;
    }
    else {
        return false;
    }
}
exports.isWebCryptoSupported = isWebCryptoSupported;
function multibaseIdToKey(options) {
    var multibaseKeyId = options.multibaseKeyId;
    var prefixedKeyB58 = common_1.Convert.multibase(multibaseKeyId).toBase58Btc();
    var prefixedKey = common_1.Convert.base58Btc(prefixedKeyB58).toUint8Array();
    var _a = common_1.Multicodec.removePrefix({ prefixedData: prefixedKey }), code = _a.code, data = _a.data, name = _a.name;
    return { key: data, multicodecCode: code, multicodecName: name };
}
exports.multibaseIdToKey = multibaseIdToKey;
/**
 * Generates secure pseudorandom values of the specified length using
 * `crypto.getRandomValues`, which defers to the operating system.
 *
 * This function is a wrapper around `randomBytes` from the '@noble/hashes'
 * package. It's designed to be cryptographically strong, suitable for
 * generating keys, initialization vectors, and other random values.
 *
 * @param bytesLength - The number of bytes to generate.
 * @returns A Uint8Array containing the generated random bytes.
 *
 * @example
 * const bytes = randomBytes(32); // Generates 32 random bytes
 *
 * @see {@link https://www.npmjs.com/package/@noble/hashes | @noble/hashes on NPM}
 * for more information about the underlying implementation.
 */
function randomBytes(bytesLength) {
    return (0, utils_1.randomBytes)(bytesLength);
}
exports.randomBytes = randomBytes;
/**
 * Generates a UUID (Universally Unique Identifier) using a
 * cryptographically strong random number generator following
 * the version 4 format, as specified in RFC 4122.
 *
 * A version 4 UUID is a randomly generated UUID. The 13th character
 * is set to '4' to denote version 4, and the 17th character is one
 * of '8', '9', 'A', or 'B' to comply with the variant 1 format of
 * UUIDs (the high bits are set to '10').
 *
 * The UUID is a 36 character string, including hyphens, and looks like this:
 * xxxxxxxx-xxxx-4xxx-axxx-xxxxxxxxxxxx
 *
 * Note that while UUIDs are not guaranteed to be unique, they are
 * practically unique" given the large number of possible UUIDs and
 * the randomness of generation.
 *
 * @returns A string containing a randomly generated, 36 character long v4 UUID.
 */
function randomUuid() {
    var uuid = crypto_1.crypto.randomUUID();
    return uuid;
}
exports.randomUuid = randomUuid;
//# sourceMappingURL=utils.js.map