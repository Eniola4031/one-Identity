"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Jose = void 0;
var sha256_1 = require("@noble/hashes/sha256");
var common_1 = require("@web5/common");
var utils_js_1 = require("./utils.js");
var index_js_1 = require("./crypto-primitives/index.js");
var multicodecToJoseMapping = {
    'ed25519-pub': { crv: 'Ed25519', kty: 'OKP', x: '' },
    'ed25519-priv': { crv: 'Ed25519', kty: 'OKP', x: '', d: '' },
    'secp256k1-pub': { crv: 'secp256k1', kty: 'EC', x: '', y: '' },
    'secp256k1-priv': { crv: 'secp256k1', kty: 'EC', x: '', y: '', d: '' },
    'x25519-pub': { crv: 'X25519', kty: 'OKP', x: '' },
    'x25519-priv': { crv: 'X25519', kty: 'OKP', x: '', d: '' },
};
var joseToMulticodecMapping = {
    'Ed25519:public': 'ed25519-pub',
    'Ed25519:private': 'ed25519-priv',
    'secp256k1:public': 'secp256k1-pub',
    'secp256k1:private': 'secp256k1-priv',
    'X25519:public': 'x25519-pub',
    'X25519:private': 'x25519-priv',
};
var Jose = /** @class */ (function () {
    function Jose() {
    }
    Jose.isEcPrivateKeyJwk = function (obj) {
        if (!obj || typeof obj !== 'object')
            return false;
        if (!('kty' in obj && 'crv' in obj && 'x' in obj && 'd' in obj))
            return false;
        if (obj.kty !== 'EC')
            return false;
        if (typeof obj.d !== 'string')
            return false;
        if (typeof obj.x !== 'string')
            return false;
        return true;
    };
    Jose.isEcPublicKeyJwk = function (obj) {
        if (!obj || typeof obj !== 'object')
            return false;
        if (!('kty' in obj && 'crv' in obj && 'x' in obj))
            return false;
        if ('d' in obj)
            return false;
        if (obj.kty !== 'EC')
            return false;
        if (typeof obj.x !== 'string')
            return false;
        return true;
    };
    Jose.isOctPrivateKeyJwk = function (obj) {
        if (!obj || typeof obj !== 'object')
            return false;
        if (!('kty' in obj && 'k' in obj))
            return false;
        if (obj.kty !== 'oct')
            return false;
        if (typeof obj.k !== 'string')
            return false;
        return true;
    };
    Jose.isOkpPrivateKeyJwk = function (obj) {
        if (!obj || typeof obj !== 'object')
            return false;
        if (!('kty' in obj && 'crv' in obj && 'x' in obj && 'd' in obj))
            return false;
        if (obj.kty !== 'OKP')
            return false;
        if (typeof obj.d !== 'string')
            return false;
        if (typeof obj.x !== 'string')
            return false;
        return true;
    };
    Jose.isOkpPublicKeyJwk = function (obj) {
        if (!obj || typeof obj !== 'object')
            return false;
        if ('d' in obj)
            return false;
        if (!('kty' in obj && 'crv' in obj && 'x' in obj))
            return false;
        if (obj.kty !== 'OKP')
            return false;
        if (typeof obj.x !== 'string')
            return false;
        return true;
    };
    Jose.joseToMulticodec = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var jsonWebKey, params, lookupKey, name, code;
            return __generator(this, function (_a) {
                jsonWebKey = options.key;
                params = [];
                if ('crv' in jsonWebKey) {
                    params.push(jsonWebKey.crv);
                    if ('d' in jsonWebKey) {
                        params.push('private');
                    }
                    else {
                        params.push('public');
                    }
                }
                lookupKey = params.join(':');
                name = joseToMulticodecMapping[lookupKey];
                if (name === undefined) {
                    throw new Error("Unsupported JOSE to Multicodec conversion: '".concat(lookupKey, "'"));
                }
                code = common_1.Multicodec.getCodeFromName({ name: name });
                return [2 /*return*/, { code: code, name: name }];
            });
        });
    };
    /**
     * Computes the thumbprint of a JSON Web Key (JWK) using the method
     * specified in RFC 7638. This function accepts RSA, EC, OKP, and oct keys
     * and returns the thumbprint as a base64url encoded SHA-256 hash of the
     * JWK's required members, serialized and sorted lexicographically.
     *
     * Purpose:
     * - Uniquely Identifying Keys: The thumbprint allows the unique
     *   identification of a specific JWK within a set of JWKs. It provides a
     *   deterministic way to generate a value that can be used as a key
     *   identifier (kid) or to match a specific key.
     *
     * - Simplifying Key Management: In systems where multiple keys are used,
     *   managing and identifying individual keys can become complex. The
     *   thumbprint method simplifies this by creating a standardized, unique
     *   identifier for each key.
     *
     * - Enabling Interoperability: By standardizing the method to compute a
     *   thumbprint, different systems can compute the same thumbprint value for
     *   a given JWK. This enables interoperability among systems that use JWKs.
     *
     * - Secure Comparison: The thumbprint provides a way to securely compare
     *   JWKs to determine if they are equivalent.
     *
     * @param jwk - The JSON Web Key for which the thumbprint will be computed.
     *              This must be an RSA, EC, OKP, or oct key.
     * @returns The thumbprint as a base64url encoded string.
     * @throws {Error} Throws an error if the provided key type is unsupported.
     *
     * @example
     * const jwk: PublicKeyJwk = {
     *   'kty': 'EC',
     *   'crv': 'secp256k1',
     *   'x': '61iPYuGefxotzBdQZtDvv6cWHZmXrTTscY-u7Y2pFZc',
     *   'y': '88nPCVLfrAY9i-wg5ORcwVbHWC_tbeAd1JE2e0co0lU'
     * };
     *
     * const thumbprint = jwkThumbprint(jwk);
     * console.log(`JWK thumbprint: ${thumbprint}`);
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc7638 | RFC7638} for
     * the specification of JWK thumbprint computation.
     */
    Jose.jwkThumbprint = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var key, keyType, normalizedJwk, serializedJwk, utf8Bytes, digest, thumbprint;
            return __generator(this, function (_a) {
                key = options.key;
                keyType = key.kty;
                if (keyType === 'EC') {
                    normalizedJwk = { crv: key.crv, kty: key.kty, x: key.x, y: key.y };
                }
                else if (keyType === 'oct') {
                    normalizedJwk = { k: key.k, kty: key.kty };
                }
                else if (keyType === 'OKP') {
                    normalizedJwk = { crv: key.crv, kty: key.kty, x: key.x };
                }
                else if (keyType === 'RSA') {
                    normalizedJwk = { e: key.e, kty: key.kty, n: key.n };
                }
                else {
                    throw new Error("Unsupported key type: ".concat(keyType));
                }
                (0, common_1.removeUndefinedProperties)(normalizedJwk);
                serializedJwk = Jose.canonicalize(normalizedJwk);
                utf8Bytes = common_1.Convert.string(serializedJwk).toUint8Array();
                digest = (0, sha256_1.sha256)(utf8Bytes);
                thumbprint = common_1.Convert.uint8Array(digest).toBase64Url();
                return [2 /*return*/, thumbprint];
            });
        });
    };
    /**
     * Note: All secp public keys are converted to compressed point encoding
     *       before the multibase identifier is computed.
     *
     * Per {@link https://github.com/multiformats/multicodec/blob/master/table.csv | Multicodec table}:
     *    Public keys for Elliptic Curve cryptography algorithms (e.g., secp256k1,
     *    secp256k1r1, secp384r1, etc.) are always represented with compressed point
     *    encoding (e.g., secp256k1-pub, p256-pub, p384-pub, etc.).
     *
     * Per {@link https://datatracker.ietf.org/doc/html/rfc8812#name-jose-and-cose-secp256k1-cur | RFC 8812}:
     *    "As a compressed point encoding representation is not defined for JWK
     *    elliptic curve points, the uncompressed point encoding defined there
     *    MUST be used. The x and y values represented MUST both be exactly
     *    256 bits, with any leading zeros preserved."
     */
    Jose.publicKeyToMultibaseId = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var publicKey, publicKeyBytes, _a, multicodecName, multibaseId;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        publicKey = options.publicKey;
                        if (!('crv' in publicKey)) {
                            throw new Error("Jose: Unsupported public key type: ".concat(publicKey.kty));
                        }
                        _a = publicKey.crv;
                        switch (_a) {
                            case 'Ed25519': return [3 /*break*/, 1];
                            case 'secp256k1': return [3 /*break*/, 3];
                            case 'X25519': return [3 /*break*/, 6];
                        }
                        return [3 /*break*/, 8];
                    case 1: return [4 /*yield*/, index_js_1.Ed25519.publicKeyToBytes({ publicKey: publicKey })];
                    case 2:
                        publicKeyBytes = _b.sent();
                        return [3 /*break*/, 9];
                    case 3: return [4 /*yield*/, index_js_1.Secp256k1.publicKeyToBytes({ publicKey: publicKey })];
                    case 4:
                        publicKeyBytes = _b.sent();
                        return [4 /*yield*/, index_js_1.Secp256k1.compressPublicKey({ publicKeyBytes: publicKeyBytes })];
                    case 5:
                        // Convert secp256k1 public keys to compressed format.
                        publicKeyBytes = _b.sent();
                        return [3 /*break*/, 9];
                    case 6: return [4 /*yield*/, index_js_1.X25519.publicKeyToBytes({ publicKey: publicKey })];
                    case 7:
                        publicKeyBytes = _b.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        {
                            throw new Error("Jose: Unsupported public key curve: ".concat(publicKey.crv));
                        }
                        _b.label = 9;
                    case 9: return [4 /*yield*/, Jose.joseToMulticodec({ key: publicKey })];
                    case 10:
                        multicodecName = (_b.sent()).name;
                        multibaseId = (0, utils_js_1.keyToMultibaseId)({ key: publicKeyBytes, multicodecName: multicodecName });
                        return [2 /*return*/, multibaseId];
                }
            });
        });
    };
    Jose.multicodecToJose = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var code, name, lookupKey, jose;
            return __generator(this, function (_a) {
                code = options.code, name = options.name;
                // Either code or name must be specified, but not both.
                if (!(name ? !code : code)) {
                    throw new Error("Either 'name' or 'code' must be defined, but not both.");
                }
                // If name is undefined, lookup by code.
                name = (name === undefined) ? common_1.Multicodec.getNameFromCode({ code: code }) : name;
                lookupKey = name;
                jose = multicodecToJoseMapping[lookupKey];
                if (jose === undefined) {
                    throw new Error("Unsupported Multicodec to JOSE conversion: '".concat(options.name, "'"));
                }
                return [2 /*return*/, __assign({}, jose)];
            });
        });
    };
    Jose.canonicalize = function (obj) {
        var sortedKeys = Object.keys(obj).sort();
        var sortedObj = sortedKeys.reduce(function (acc, key) {
            acc[key] = obj[key];
            return acc;
        }, {});
        return JSON.stringify(sortedObj);
    };
    return Jose;
}());
exports.Jose = Jose;
//# sourceMappingURL=jose.js.map