"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoAlgorithm = void 0;
var errors_js_1 = require("./errors.js");
var CryptoAlgorithm = /** @class */ (function () {
    function CryptoAlgorithm() {
    }
    CryptoAlgorithm.prototype.checkAlgorithmName = function (options) {
        var algorithmName = options.algorithmName;
        if (algorithmName === undefined) {
            throw new TypeError("Required parameter missing: 'algorithmName'");
        }
        if (!this.names.includes(algorithmName)) {
            throw new errors_js_1.NotSupportedError("Algorithm not supported: '".concat(algorithmName, "'"));
        }
    };
    CryptoAlgorithm.prototype.checkJwk = function (options) {
        var key = options.key;
        if (typeof key !== 'object' || !('kty' in key)) {
            throw new TypeError('Object is not a JSON Web Key (JWK)');
        }
    };
    CryptoAlgorithm.prototype.checkKeyAlgorithm = function (options) {
        var keyAlgorithmName = options.keyAlgorithmName;
        if (keyAlgorithmName === undefined) {
            throw new TypeError("Required parameter missing: 'keyAlgorithmName'");
        }
        if (keyAlgorithmName && !this.names.includes(keyAlgorithmName)) {
            throw new errors_js_1.InvalidAccessError("Algorithm '".concat(this.names.join(', '), "' does not match the provided '").concat(keyAlgorithmName, "' key."));
        }
    };
    CryptoAlgorithm.prototype.checkKeyType = function (options) {
        var keyType = options.keyType, allowedKeyTypes = options.allowedKeyTypes;
        if (keyType === undefined || allowedKeyTypes === undefined) {
            throw new TypeError("One or more required parameters missing: 'keyType, allowedKeyTypes'");
        }
        if (!Array.isArray(allowedKeyTypes)) {
            throw new TypeError("The provided 'allowedKeyTypes' is not of type Array.");
        }
        if (keyType && !allowedKeyTypes.includes(keyType)) {
            throw new errors_js_1.InvalidAccessError("Key type of the provided key must be '".concat(allowedKeyTypes.join(', '), "' but '").concat(keyType, "' was specified."));
        }
    };
    CryptoAlgorithm.prototype.checkKeyOperations = function (options) {
        var keyOperations = options.keyOperations, allowedKeyOperations = options.allowedKeyOperations;
        if (!(keyOperations && keyOperations.length > 0)) {
            throw new TypeError("Required parameter missing or empty: 'keyOperations'");
        }
        if (!Array.isArray(allowedKeyOperations)) {
            throw new TypeError("The provided 'allowedKeyOperations' is not of type Array.");
        }
        if (!keyOperations.every(function (operation) { return allowedKeyOperations.includes(operation); })) {
            throw new errors_js_1.InvalidAccessError("Requested operation(s) '".concat(keyOperations.join(', '), "' is not valid for the provided key."));
        }
    };
    /**
     * Creates an instance of the class on which it is called.
     *
     * This is a generic factory method that creates an instance of any
     * crypto algorithm that extends this abstract class.
     *
     * @template T The type of the instance to be created.
     * @returns An instance of the class it is called on.
     * @throws {TypeError} If the class it is called on cannot be constructed.
     */
    CryptoAlgorithm.create = function () {
        return new this();
    };
    return CryptoAlgorithm;
}());
exports.CryptoAlgorithm = CryptoAlgorithm;
//# sourceMappingURL=crypto-algorithm.js.map