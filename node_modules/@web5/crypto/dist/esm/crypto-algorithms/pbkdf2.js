var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Convert } from '@web5/common';
import { Pbkdf2 } from '../crypto-primitives/pbkdf2.js';
import { BasePbkdf2Algorithm, OperationError } from '../algorithms-api/index.js';
export class Pbkdf2Algorithm extends BasePbkdf2Algorithm {
    constructor() {
        super(...arguments);
        this.names = ['PBKDF2'];
        this.hashAlgorithms = ['SHA-256', 'SHA-384', 'SHA-512'];
    }
    deriveBits(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { algorithm, baseKey, length } = options;
            // Check the `algorithm` and `baseKey` values for PBKDF2 requirements.
            this.checkAlgorithmOptions({ algorithm, baseKey });
            // If specified, the base key's `key_ops` must include the 'deriveBits' operation.
            if (baseKey.key_ops) {
                this.checkKeyOperations({ keyOperations: ['deriveBits'], allowedKeyOperations: baseKey.key_ops });
            }
            // If the length is 0, throw.
            if (typeof length !== 'undefined' && length === 0) {
                throw new OperationError(`The value of 'length' cannot be zero.`);
            }
            // If the length is not a multiple of 8, throw.
            if (length && length % 8 !== 0) {
                throw new OperationError(`To be compatible with all browsers, 'length' must be a multiple of 8.`);
            }
            // Convert the base key to bytes.
            const baseKeyBytes = Convert.base64Url(baseKey.k).toUint8Array();
            const derivedBits = Pbkdf2.deriveKey({
                hash: algorithm.hash,
                iterations: algorithm.iterations,
                length: length,
                password: baseKeyBytes,
                salt: algorithm.salt
            });
            return derivedBits;
        });
    }
}
//# sourceMappingURL=pbkdf2.js.map