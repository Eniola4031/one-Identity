import { InvalidAccessError, NotSupportedError } from './errors.js';
export class CryptoAlgorithm {
    checkAlgorithmName(options) {
        const { algorithmName } = options;
        if (algorithmName === undefined) {
            throw new TypeError(`Required parameter missing: 'algorithmName'`);
        }
        if (!this.names.includes(algorithmName)) {
            throw new NotSupportedError(`Algorithm not supported: '${algorithmName}'`);
        }
    }
    checkJwk(options) {
        const { key } = options;
        if (typeof key !== 'object' || !('kty' in key)) {
            throw new TypeError('Object is not a JSON Web Key (JWK)');
        }
    }
    checkKeyAlgorithm(options) {
        const { keyAlgorithmName } = options;
        if (keyAlgorithmName === undefined) {
            throw new TypeError(`Required parameter missing: 'keyAlgorithmName'`);
        }
        if (keyAlgorithmName && !this.names.includes(keyAlgorithmName)) {
            throw new InvalidAccessError(`Algorithm '${this.names.join(', ')}' does not match the provided '${keyAlgorithmName}' key.`);
        }
    }
    checkKeyType(options) {
        const { keyType, allowedKeyTypes } = options;
        if (keyType === undefined || allowedKeyTypes === undefined) {
            throw new TypeError(`One or more required parameters missing: 'keyType, allowedKeyTypes'`);
        }
        if (!Array.isArray(allowedKeyTypes)) {
            throw new TypeError(`The provided 'allowedKeyTypes' is not of type Array.`);
        }
        if (keyType && !allowedKeyTypes.includes(keyType)) {
            throw new InvalidAccessError(`Key type of the provided key must be '${allowedKeyTypes.join(', ')}' but '${keyType}' was specified.`);
        }
    }
    checkKeyOperations(options) {
        const { keyOperations, allowedKeyOperations } = options;
        if (!(keyOperations && keyOperations.length > 0)) {
            throw new TypeError(`Required parameter missing or empty: 'keyOperations'`);
        }
        if (!Array.isArray(allowedKeyOperations)) {
            throw new TypeError(`The provided 'allowedKeyOperations' is not of type Array.`);
        }
        if (!keyOperations.every(operation => allowedKeyOperations.includes(operation))) {
            throw new InvalidAccessError(`Requested operation(s) '${keyOperations.join(', ')}' is not valid for the provided key.`);
        }
    }
    /**
     * Creates an instance of the class on which it is called.
     *
     * This is a generic factory method that creates an instance of any
     * crypto algorithm that extends this abstract class.
     *
     * @template T The type of the instance to be created.
     * @returns An instance of the class it is called on.
     * @throws {TypeError} If the class it is called on cannot be constructed.
     */
    static create() {
        return new this();
    }
}
//# sourceMappingURL=crypto-algorithm.js.map