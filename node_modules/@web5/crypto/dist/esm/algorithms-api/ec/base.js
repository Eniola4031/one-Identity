var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { universalTypeOf } from '@web5/common';
import { Jose } from '../../jose.js';
import { InvalidAccessError } from '../errors.js';
import { CryptoAlgorithm } from '../crypto-algorithm.js';
import { checkValidProperty, checkRequiredProperty } from '../../utils.js';
export class BaseEllipticCurveAlgorithm extends CryptoAlgorithm {
    checkGenerateKeyOptions(options) {
        const { algorithm, keyOperations } = options;
        // Algorithm specified in the operation must match the algorithm implementation processing the operation.
        this.checkAlgorithmName({ algorithmName: algorithm.name });
        // The algorithm object must contain a curve property.
        checkRequiredProperty({ property: 'curve', inObject: algorithm });
        // The curve specified must be supported by the algorithm implementation processing the operation.
        checkValidProperty({ property: algorithm.curve, allowedProperties: this.curves });
        // If specified, key operations must be permitted by the algorithm implementation processing the operation.
        if (keyOperations) {
            this.checkKeyOperations({ keyOperations, allowedKeyOperations: this.keyOperations });
        }
    }
    checkSignOptions(options) {
        const { algorithm, data, key } = options;
        // Algorithm specified in the operation must match the algorithm implementation processing the operation.
        this.checkAlgorithmName({ algorithmName: algorithm.name });
        // The key object must be an Elliptic Curve (EC) or Octet Key Pair (OKP) private key in JWK format.
        if (!(Jose.isEcPrivateKeyJwk(key) || Jose.isOkpPrivateKeyJwk(key))) {
            throw new InvalidAccessError('Requested operation is only valid for private keys.');
        }
        // The curve specified must be supported by the algorithm implementation processing the operation.
        checkValidProperty({ property: key.crv, allowedProperties: this.curves });
        // The data must be a Uint8Array.
        if (universalTypeOf(data) !== 'Uint8Array') {
            throw new TypeError('The data must be of type Uint8Array.');
        }
        // If specified, the key's algorithm must match the algorithm implementation processing the operation.
        if (key.alg) {
            this.checkKeyAlgorithm({ keyAlgorithmName: key.alg });
        }
        // If specified, the key's `key_ops` must include the 'sign' operation.
        if (key.key_ops) {
            this.checkKeyOperations({ keyOperations: ['sign'], allowedKeyOperations: key.key_ops });
        }
    }
    checkVerifyOptions(options) {
        const { algorithm, key, signature, data } = options;
        // Algorithm specified in the operation must match the algorithm implementation processing the operation.
        this.checkAlgorithmName({ algorithmName: algorithm.name });
        // The key object must be an Elliptic Curve (EC) or Octet Key Pair (OKP) public key in JWK format.
        if (!(Jose.isEcPublicKeyJwk(key) || Jose.isOkpPublicKeyJwk(key))) {
            throw new InvalidAccessError('Requested operation is only valid for public keys.');
        }
        // The curve specified must be supported by the algorithm implementation processing the operation.
        checkValidProperty({ property: key.crv, allowedProperties: this.curves });
        // The signature must be a Uint8Array.
        if (universalTypeOf(signature) !== 'Uint8Array') {
            throw new TypeError('The signature must be of type Uint8Array.');
        }
        // The data must be a Uint8Array.
        if (universalTypeOf(data) !== 'Uint8Array') {
            throw new TypeError('The data must be of type Uint8Array.');
        }
        // If specified, the key's algorithm must match the algorithm implementation processing the operation.
        if (key.alg) {
            this.checkKeyAlgorithm({ keyAlgorithmName: key.alg });
        }
        // If specified, the key's `key_ops` must include the 'verify' operation.
        if (key.key_ops) {
            this.checkKeyOperations({ keyOperations: ['verify'], allowedKeyOperations: key.key_ops });
        }
    }
    decrypt() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new InvalidAccessError(`Requested operation 'decrypt' is not valid for Elliptic Curve algorithms.`);
        });
    }
    encrypt() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new InvalidAccessError(`Requested operation 'encrypt' is not valid for Elliptic Curve algorithms.`);
        });
    }
}
//# sourceMappingURL=base.js.map