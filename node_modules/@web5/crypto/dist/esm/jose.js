var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { sha256 } from '@noble/hashes/sha256';
import { Convert, Multicodec, removeUndefinedProperties } from '@web5/common';
import { keyToMultibaseId } from './utils.js';
import { Ed25519, Secp256k1, X25519 } from './crypto-primitives/index.js';
const multicodecToJoseMapping = {
    'ed25519-pub': { crv: 'Ed25519', kty: 'OKP', x: '' },
    'ed25519-priv': { crv: 'Ed25519', kty: 'OKP', x: '', d: '' },
    'secp256k1-pub': { crv: 'secp256k1', kty: 'EC', x: '', y: '' },
    'secp256k1-priv': { crv: 'secp256k1', kty: 'EC', x: '', y: '', d: '' },
    'x25519-pub': { crv: 'X25519', kty: 'OKP', x: '' },
    'x25519-priv': { crv: 'X25519', kty: 'OKP', x: '', d: '' },
};
const joseToMulticodecMapping = {
    'Ed25519:public': 'ed25519-pub',
    'Ed25519:private': 'ed25519-priv',
    'secp256k1:public': 'secp256k1-pub',
    'secp256k1:private': 'secp256k1-priv',
    'X25519:public': 'x25519-pub',
    'X25519:private': 'x25519-priv',
};
export class Jose {
    static isEcPrivateKeyJwk(obj) {
        if (!obj || typeof obj !== 'object')
            return false;
        if (!('kty' in obj && 'crv' in obj && 'x' in obj && 'd' in obj))
            return false;
        if (obj.kty !== 'EC')
            return false;
        if (typeof obj.d !== 'string')
            return false;
        if (typeof obj.x !== 'string')
            return false;
        return true;
    }
    static isEcPublicKeyJwk(obj) {
        if (!obj || typeof obj !== 'object')
            return false;
        if (!('kty' in obj && 'crv' in obj && 'x' in obj))
            return false;
        if ('d' in obj)
            return false;
        if (obj.kty !== 'EC')
            return false;
        if (typeof obj.x !== 'string')
            return false;
        return true;
    }
    static isOctPrivateKeyJwk(obj) {
        if (!obj || typeof obj !== 'object')
            return false;
        if (!('kty' in obj && 'k' in obj))
            return false;
        if (obj.kty !== 'oct')
            return false;
        if (typeof obj.k !== 'string')
            return false;
        return true;
    }
    static isOkpPrivateKeyJwk(obj) {
        if (!obj || typeof obj !== 'object')
            return false;
        if (!('kty' in obj && 'crv' in obj && 'x' in obj && 'd' in obj))
            return false;
        if (obj.kty !== 'OKP')
            return false;
        if (typeof obj.d !== 'string')
            return false;
        if (typeof obj.x !== 'string')
            return false;
        return true;
    }
    static isOkpPublicKeyJwk(obj) {
        if (!obj || typeof obj !== 'object')
            return false;
        if ('d' in obj)
            return false;
        if (!('kty' in obj && 'crv' in obj && 'x' in obj))
            return false;
        if (obj.kty !== 'OKP')
            return false;
        if (typeof obj.x !== 'string')
            return false;
        return true;
    }
    static joseToMulticodec(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const jsonWebKey = options.key;
            const params = [];
            if ('crv' in jsonWebKey) {
                params.push(jsonWebKey.crv);
                if ('d' in jsonWebKey) {
                    params.push('private');
                }
                else {
                    params.push('public');
                }
            }
            const lookupKey = params.join(':');
            const name = joseToMulticodecMapping[lookupKey];
            if (name === undefined) {
                throw new Error(`Unsupported JOSE to Multicodec conversion: '${lookupKey}'`);
            }
            const code = Multicodec.getCodeFromName({ name });
            return { code, name };
        });
    }
    /**
     * Computes the thumbprint of a JSON Web Key (JWK) using the method
     * specified in RFC 7638. This function accepts RSA, EC, OKP, and oct keys
     * and returns the thumbprint as a base64url encoded SHA-256 hash of the
     * JWK's required members, serialized and sorted lexicographically.
     *
     * Purpose:
     * - Uniquely Identifying Keys: The thumbprint allows the unique
     *   identification of a specific JWK within a set of JWKs. It provides a
     *   deterministic way to generate a value that can be used as a key
     *   identifier (kid) or to match a specific key.
     *
     * - Simplifying Key Management: In systems where multiple keys are used,
     *   managing and identifying individual keys can become complex. The
     *   thumbprint method simplifies this by creating a standardized, unique
     *   identifier for each key.
     *
     * - Enabling Interoperability: By standardizing the method to compute a
     *   thumbprint, different systems can compute the same thumbprint value for
     *   a given JWK. This enables interoperability among systems that use JWKs.
     *
     * - Secure Comparison: The thumbprint provides a way to securely compare
     *   JWKs to determine if they are equivalent.
     *
     * @param jwk - The JSON Web Key for which the thumbprint will be computed.
     *              This must be an RSA, EC, OKP, or oct key.
     * @returns The thumbprint as a base64url encoded string.
     * @throws {Error} Throws an error if the provided key type is unsupported.
     *
     * @example
     * const jwk: PublicKeyJwk = {
     *   'kty': 'EC',
     *   'crv': 'secp256k1',
     *   'x': '61iPYuGefxotzBdQZtDvv6cWHZmXrTTscY-u7Y2pFZc',
     *   'y': '88nPCVLfrAY9i-wg5ORcwVbHWC_tbeAd1JE2e0co0lU'
     * };
     *
     * const thumbprint = jwkThumbprint(jwk);
     * console.log(`JWK thumbprint: ${thumbprint}`);
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc7638 | RFC7638} for
     * the specification of JWK thumbprint computation.
     */
    static jwkThumbprint(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { key } = options;
            /** Step 1 - Normalization: The JWK is normalized to include only specific
             * members and in lexicographic order.
             */
            const keyType = key.kty;
            let normalizedJwk;
            if (keyType === 'EC') {
                normalizedJwk = { crv: key.crv, kty: key.kty, x: key.x, y: key.y };
            }
            else if (keyType === 'oct') {
                normalizedJwk = { k: key.k, kty: key.kty };
            }
            else if (keyType === 'OKP') {
                normalizedJwk = { crv: key.crv, kty: key.kty, x: key.x };
            }
            else if (keyType === 'RSA') {
                normalizedJwk = { e: key.e, kty: key.kty, n: key.n };
            }
            else {
                throw new Error(`Unsupported key type: ${keyType}`);
            }
            removeUndefinedProperties(normalizedJwk);
            /** Step 2 - Serialization: The normalized JWK is serialized to a UTF-8
             * representation of its JSON encoding. */
            const serializedJwk = Jose.canonicalize(normalizedJwk);
            /** Step 3 - Digest Calculation: A cryptographic hash function
             * (SHA-256 is recommended) is applied to the serialized JWK,
             * resulting in the thumbprint. */
            const utf8Bytes = Convert.string(serializedJwk).toUint8Array();
            const digest = sha256(utf8Bytes);
            // Encode as Base64Url.
            const thumbprint = Convert.uint8Array(digest).toBase64Url();
            return thumbprint;
        });
    }
    /**
     * Note: All secp public keys are converted to compressed point encoding
     *       before the multibase identifier is computed.
     *
     * Per {@link https://github.com/multiformats/multicodec/blob/master/table.csv | Multicodec table}:
     *    Public keys for Elliptic Curve cryptography algorithms (e.g., secp256k1,
     *    secp256k1r1, secp384r1, etc.) are always represented with compressed point
     *    encoding (e.g., secp256k1-pub, p256-pub, p384-pub, etc.).
     *
     * Per {@link https://datatracker.ietf.org/doc/html/rfc8812#name-jose-and-cose-secp256k1-cur | RFC 8812}:
     *    "As a compressed point encoding representation is not defined for JWK
     *    elliptic curve points, the uncompressed point encoding defined there
     *    MUST be used. The x and y values represented MUST both be exactly
     *    256 bits, with any leading zeros preserved."
     */
    static publicKeyToMultibaseId(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { publicKey } = options;
            if (!('crv' in publicKey)) {
                throw new Error(`Jose: Unsupported public key type: ${publicKey.kty}`);
            }
            let publicKeyBytes;
            switch (publicKey.crv) {
                case 'Ed25519': {
                    publicKeyBytes = yield Ed25519.publicKeyToBytes({ publicKey });
                    break;
                }
                case 'secp256k1': {
                    publicKeyBytes = yield Secp256k1.publicKeyToBytes({ publicKey });
                    // Convert secp256k1 public keys to compressed format.
                    publicKeyBytes = yield Secp256k1.compressPublicKey({ publicKeyBytes });
                    break;
                }
                case 'X25519': {
                    publicKeyBytes = yield X25519.publicKeyToBytes({ publicKey });
                    break;
                }
                default: {
                    throw new Error(`Jose: Unsupported public key curve: ${publicKey.crv}`);
                }
            }
            // Convert the JSON Web Key (JWK) parameters to a Multicodec name.
            const { name: multicodecName } = yield Jose.joseToMulticodec({ key: publicKey });
            // Compute the multibase identifier based on the provided key.
            const multibaseId = keyToMultibaseId({ key: publicKeyBytes, multicodecName });
            return multibaseId;
        });
    }
    static multicodecToJose(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let { code, name } = options;
            // Either code or name must be specified, but not both.
            if (!(name ? !code : code)) {
                throw new Error(`Either 'name' or 'code' must be defined, but not both.`);
            }
            // If name is undefined, lookup by code.
            name = (name === undefined) ? Multicodec.getNameFromCode({ code: code }) : name;
            const lookupKey = name;
            const jose = multicodecToJoseMapping[lookupKey];
            if (jose === undefined) {
                throw new Error(`Unsupported Multicodec to JOSE conversion: '${options.name}'`);
            }
            return Object.assign({}, jose);
        });
    }
    static canonicalize(obj) {
        const sortedKeys = Object.keys(obj).sort();
        const sortedObj = sortedKeys.reduce((acc, key) => {
            acc[key] = obj[key];
            return acc;
        }, {});
        return JSON.stringify(sortedObj);
    }
}
//# sourceMappingURL=jose.js.map